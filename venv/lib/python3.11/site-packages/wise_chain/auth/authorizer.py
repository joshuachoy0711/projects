import datetime
import json
import logging
import os
from pathlib import Path
from typing import Optional

import requests
from pydantic import BaseModel, ConfigDict
from wise_security.sts.client import STSAuth

from wise_chain.auth import discovery, util
from wise_chain.auth.credential_manager import Credential, CredentialManager
from wise_chain.auth.exceptions import AuthorizationError, NoAuthorizationCode
from wise_chain.auth.pkce_secret import PKCESecret
from wise_chain.auth.redirect_server import RedirectServer


class AuthSession(BaseModel):
    session: requests.Session
    expires_at: Optional[datetime.datetime] = None
    model_config = ConfigDict(arbitrary_types_allowed=True)

    def expired(self) -> bool:
        now = datetime.datetime.now()
        return self.expires_at is not None and now >= self.expires_at

    def long_lived(self) -> bool:
        return self.expires_at is None

    def __str__(self):
        return f'{self.session_type}: {self.session}'


class Authorizer:
    """Authorizes users for MLP CLI access. It uses the OAuth2 flow to get
    user credentials and saves them to a file controlled by the credentials manager."""

    def __init__(
        self,
        credential_manager: CredentialManager,
        issuer: str,
        client_id: str,
        redirect_uri: str,
        scope: str,
        session: requests.Session = requests.Session(),
    ) -> None:
        """Create a new `Authorizer` to manage local authentication.

        Parameters
        ----------
        credential_manager : CredentialManager
            The manager used for saving & caching credentials
        issuer : str
            The auth issuer
        client_id : str
            The auth client id
        redirect_uri : str,
            The auth redirect uri
        scope : str
            The auth scope
        session : requests.Session, optional
            The session that will be give authenticated headers, by default requests.Session()
        """
        self.logger = logging.getLogger(__name__)
        self.session = session
        self.credential_manager = credential_manager

        self.issuer = issuer
        self.client_id = client_id
        self.redirect_uri = redirect_uri
        self.scope = scope

        # In-memory credentials for fast access
        self.credential: Optional[Credential] = None

    def _update_session_headers(self) -> None:
        if self.credential is not None:
            self.session.headers.update({'Authorization': f'Bearer {self.credential.id_token}'})

    def authorize(self) -> None:
        """Authorizes the user using the OAuth2 flow. If the user has already authorized
        and valid credentials are found, then it will be used. At the end of this method,
        the session at `AuthManager.session` will have the necessary headers to make
        authenticated requests.
        """
        # If the credentials file doesn't exist, try looking for credentials file and create one if it doesn't exist
        if not self.credential:
            self.logger.debug('No cached credentials found. Looking for credentials file.')
            self.credential = self.credential_manager.get_credentials()

        # If the found credential is expired, doesn't exist, or is malformed: authenticate
        if self.credential.is_expired() or self.credential.id_token is None:
            self.logger.debug("Credentials file expired or doesn't exist. Authenticating.")
            self.credential = self.oauth_flow()
            self.credential_manager.save_credentials(self.credential)
            self._update_session_headers()

        else:
            self.logger.debug('Using credentials from credentials file.')
            self._update_session_headers()

    def oauth_flow(self) -> Credential:
        """Takes the user through the OAuth flow"""
        self.logger.debug('Starting authorization flow')
        provider_config = discovery.fetch_provider_config(self.issuer)
        pkce_secret = PKCESecret()

        code = None

        with RedirectServer.from_redirect_uri(self.redirect_uri) as server:
            util.open_authorization_endpoint(
                endpoint=provider_config.authorization_endpoint,
                client_id=self.client_id,
                redirect_uri=self.redirect_uri,
                state=server.state,
                scope=self.scope,
                pkce_secret=pkce_secret,
            )

            while not server.code and not server.error:
                server.handle_request()

            if server.error is not None:
                raise AuthorizationError('Error during authorization') from server.error

            if not server.code:
                # This should never happen, handler should return code or error
                raise NoAuthorizationCode('No authorization code found. Please contact #ml-platform-public')

            code = server.code

        data = {
            'grant_type': 'authorization_code',
            'client_id': self.client_id,
            'code': code,
            'redirect_uri': self.redirect_uri,
            'code_verifier': str(pkce_secret),
        }

        try:
            response = requests.post(provider_config.token_endpoint, data=data)
            response.raise_for_status()

        except requests.exceptions.RequestException as error:
            raise AuthorizationError(f'Error from auth server {error}') from error

        try:
            token_data = response.json()

        except json.JSONDecodeError as error:
            raise AuthorizationError(f'Error decoding response from auth server {error}') from error

        credentials = Credential(
            access_token=token_data.get('access_token'),
            token_type=token_data.get('token_type'),
            expires_in=token_data.get('expires_in'),
            expires_at=int(datetime.datetime.now().timestamp()) + int(token_data.get('expires_in')),
            scope=token_data.get('scope'),
            id_token=token_data.get('id_token'),
        )

        if credentials.id_token is None:
            raise AuthorizationError('No id_token in token response')

        if credentials.expires_in is None:
            raise AuthorizationError('No expires_in in token response')

        credentials.expires_at = int(datetime.datetime.now().timestamp()) + credentials.expires_in
        return credentials


def get_llm_gateway_authorizer(session: requests.Session = requests.Session()) -> Authorizer:
    """Convenience method to create an Authorizer for the LLM Gateway.

    Parameters
    ----------
    session : Session, optional
        The session that will be authorized at the end of the OAuth flow, by default Session()

    Returns
    -------
    Authorizer
        An authorize that has been configured for LLM Gateway
    """
    credential_path = Path.home() / '.llm_gateway' / 'credentials'

    return Authorizer(
        session=session,
        credential_manager=CredentialManager(credential_path=credential_path),
        issuer='https://transferwise.okta-emea.com',
        client_id='0oaax3549aXzhakTj0i7',
        redirect_uri='http://localhost:15432/oauth2/callback',
        scope='openid profile email',
    )


def get_authorized_session(service_or_user: str, ml_prod: bool) -> AuthSession:
    """Convenience method to create an authorized session for the LLM Gateway.

    Parameters
    ----------
    service_or_user : str
        Flag to authorize as a service or user: 'service' or 'user'
    ml_prod : bool
        Flag to indicate if we're in the ml-production environment

    Returns
    -------
    requests.Session
        An authorized session for the LLM Gateway

    Raises
    ------
    AuthorizationError
        If the user token can't be fetched
    """
    session = requests.Session()

    if ml_prod:
        region = os.getenv('REGION_NAME', 'eu-central-1')
        sts_auth = STSAuth(region=region)
        session.headers.update({'x-aws-presigned-url': sts_auth.generate_token()})
        ts = datetime.datetime.now() + datetime.timedelta(minutes=10)
        return AuthSession(session=session, expires_at=ts)

    elif service_or_user == 'user':
        authorizer = get_llm_gateway_authorizer(session=session)
        authorizer.authorize()

        if authorizer.credential is None or authorizer.credential.id_token is None:
            raise AuthorizationError('Failed to get user token')

    return AuthSession(session=session, expires_at=None)


def update_session(given_session: Optional[AuthSession], service_or_user: str, ml_prod: bool) -> AuthSession:
    """
    Create an authorized requests.session.

    1. If there is no session, create fresh.
    2. If a session exists, check if it is long-lived.
        1. Check expiry for tokens with short lives.
        2. If the token has expired, create fresh.
    """
    if not given_session:
        session = get_authorized_session(service_or_user, ml_prod)
        if not session.long_lived() and session.expired():
            return get_authorized_session(service_or_user, ml_prod)
        return session
    return given_session
