from __future__ import annotations

import base64
import random
import string
from http import HTTPStatus
from http.server import BaseHTTPRequestHandler, HTTPServer
from socket import socket
from typing import Any
from urllib.parse import parse_qs, urlparse


class AuthorizationCodeHandler(BaseHTTPRequestHandler):
    """Handle the callback from the OAuth2 server"""

    def __init__(
        self, request: socket | tuple[bytes, socket], client_address: tuple[str, int], server: RedirectServer
    ) -> None:
        super().__init__(request, client_address, server)
        self.server: RedirectServer = server

    def log_message(self, fmt: str, *args: Any) -> None:
        """Disable logging for the callback handler"""

    def do_GET(self) -> None:
        url = urlparse(self.path)

        # Ignore request to a path different from the specified redirection
        if url.path != self.server.redirection_path:
            self.send_error(HTTPStatus.NOT_FOUND, message='Not found')
            return

        qs = parse_qs(url.query)

        error = qs.get('error')
        if error:
            error_description = qs.get('error_description', error)[0]
            self.send_error(HTTPStatus.UNAUTHORIZED, message=f'OAuth error: {error_description}')
            self.server.error = Exception(f'OAuth error: {error_description}')
            return

        try:
            (query_state,) = qs.get('state', [])
            if query_state != self.server.state:
                self.server.error = Exception(
                    'bad state in OAuth redirect URI: ' f"'{query_state}', expected '{self.server.state}'."
                )

        except (TypeError, ValueError):
            self.server.error = Exception('no state in OAuth redirect URI.')

        try:
            (self.server.code,) = qs.get('code', [])

        except (TypeError, ValueError):
            self.server.error = Exception('no code in OAuth redirect URI.')

        if self.server.error:
            self.send_error(HTTPStatus.BAD_REQUEST, message=f'OAuth error: {self.server.error}')
            return

        self.send_response(200)
        self.send_header('Content-type', 'text/html')
        self.end_headers()
        self.wfile.write(b'Authorization successful! You can close this browser window.')


class RedirectServer(HTTPServer):
    """Local HTTP server to handle an OAuth authorization redirect."""

    def __init__(
        self, server_address: tuple[str, int], handler_class: type[AuthorizationCodeHandler], redirection_path: str
    ):
        super().__init__(server_address, handler_class)
        self.redirection_path = redirection_path or '/'
        self.state = base64.urlsafe_b64encode(
            ''.join(random.choices(string.ascii_letters + string.digits + '-._~', k=32)).encode()
        ).decode()

        self.code: str | None = None
        self.error: Exception | None = None

    @classmethod
    def from_redirect_uri(cls, redirect_uri: str) -> RedirectServer:
        """Create a local HTTP server  to handle an OAuth authorization redirect."""

        url = urlparse(redirect_uri)

        if not url.hostname or not url.port:
            raise ValueError('cannot start callback server without hostname and port.')

        return cls((url.hostname, url.port), AuthorizationCodeHandler, redirection_path=url.path)
