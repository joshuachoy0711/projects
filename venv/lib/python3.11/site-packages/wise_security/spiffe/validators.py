import os
import sys
from typing import List

from wise_security.errors import Forbidden, RequiredEnvVarException
from wise_security.ws_typing import AuthorizedService

from .logger import logger
from .spiffeid import SpiffeID
from .trust_domain import TrustDomain

# determines the trust domain of the current service. Any service rules that don't have a trust domain
# specified will use the same trust domain as the service, i.e. the value of this property.
DEFAULT_TRUST_DOMAIN_EN_VAR = 'SPIRE_TRUST_DOMAIN'
_LOOPBACK_ADDRS = {'127.0.0.1', 'localhost'}


def validate_spiffe(spiffe_id: str, authorized_services: List[AuthorizedService], remote_address_host: str):
    """
    Check if the incoming spiffe ID is among the authorized services spiffe IDs
    Args:
        spiffe_id: Spiffe ID of a downstream service
        authorized_services: list of authorized services
        remote_address_host: address where the request is coming from

    Raises: Forbidden if not don't have valid or authorized Spiffe ID
    """

    # SPIFFE checks will only run if SPIFFE_ENABLED is truthy
    # This is to match the way wise-security java library configures spiffe checks.
    if not os.getenv('SPIFFE_ENABLED'):
        logger.warning('SPIFFE_ENABLED is off! Letting request through with no checks')
        return

    # Each service has its own trust domain injected at runtime in K8s
    if not os.getenv(DEFAULT_TRUST_DOMAIN_EN_VAR):
        raise RequiredEnvVarException(f'The service trust domain env var not found {DEFAULT_TRUST_DOMAIN_EN_VAR}')

    # why would you pass an empty list of authorized services? might as well not run spiffe checks.
    if not authorized_services:
        raise ValueError('Authorized services cannot be an empty list!')

    # A legit request can only come from localhost, i.e thru envoy
    if not (remote_address_host and remote_address_host in _LOOPBACK_ADDRS):
        logger.error(f'Request remote address is not loopback: {remote_address_host}')
        raise Forbidden('Spiffe header specified by non-loopback address')

    try:
        spiffe = SpiffeID.from_id(spiffe_id)
    except ValueError:
        logger.error(sys.exc_info()[1])
        raise Forbidden(f'Invalid Spiffe ID: {spiffe_id}')

    default_trust_domain = TrustDomain.from_str(os.environ[DEFAULT_TRUST_DOMAIN_EN_VAR])

    is_authorized = False
    for authz_service in authorized_services:
        if spiffe == _get_spiffe_of_authorized_service(authz_service, default_trust_domain):
            is_authorized = True
            break

    if not is_authorized:
        logger.debug(f'Downstream spiffe id "{spiffe_id}" does not match any of the authorized services\'s')
        raise Forbidden(f'Unauthorised Spiffe ID: {spiffe_id}')

    logger.debug(f'Downstream spiffe id "{spiffe_id}" is authorized!')


def _get_spiffe_of_authorized_service(
    authorized_service: AuthorizedService, default_trust_domain: TrustDomain
) -> SpiffeID:
    """
    Constructs the Spiffe ID instance for the given service
    Args:
        authorized_service: an instance of AuthorizedService
        default_trust_domain: the default trust domain

    Returns: Spiffe instance of the service
    """
    trust_domain = TrustDomain(
        internal_trust_domain=(
            authorized_service.internal_trust_domain
            if authorized_service.internal_trust_domain
            else default_trust_domain.internal_trust_domain
        ),
        environment=default_trust_domain.environment,
    )

    return SpiffeID(service=authorized_service.service, trust_domain=trust_domain)
