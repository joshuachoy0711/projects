"""Helper functions to send messages to Slack."""

from typing import List
import logging

from slack_sdk import WebClient
from slack_sdk.errors import SlackApiError

from treasury_ml_utils.constants import MLFLOW_EXPERIMENT_URL, MLFLOW_TRACKING_URI, MODEL_REGISTRY_REPO
from treasury_ml_utils.mlflow_utils import get_experiment_id, get_model_run_id_dict


def send_message_to_slack(token: str, channel: str, message: str = None, blocks: list = None):
    """
    Send message to the specified Slack channel.

    :param token: Airflow variable 'slack_bot_token'
    :param channel: ID of the channel in Slack
        (click on the channel name at the top pane and scroll down)
    :param message: to be sent to Slack
    :param blocks: either message or blocks should be provided
    """
    client = WebClient(token=token)

    try:
        result = client.chat_postMessage(
            channel=channel,
            text=message,
            blocks=blocks,
            link_names=True
        )
        logging.info(result)

    except SlackApiError as error:
        logging.warning(f'Error posting message: {error}')


def send_file_to_slack(token: str, channel: str, file_path: str, title: str = None, message: str = None):
    """
    Upload a file to the specified Slack channel.
    """
    client = WebClient(token=token)

    try:
        result = client.files_upload_v2(
            channel=channel,
            file=file_path,
            title=title,
            initial_comment=message
        )
        logging.info(f"File uploaded successfully: {result.get('file', {}).get('permalink', '')}")
        return result

    except SlackApiError as error:
        logging.warning(f'Error uploading file: {error}')
        return None


def create_training_message_blocks(
        experiment_name: str,
        run_dict: dict,
        sub_team: str,
        validation_path: str,
        mlflow_path: str
) -> list:
    """
    Create a message block for the Slack notification after model training of a mlflow experiment.
    """
    blocks = [
        {
            'type': 'header',
            'text': {
                'type': 'plain_text',
                'text': f'Finished retraining the {experiment_name} model :bell-tapestry:'
            }
        },
        {
            'type': 'section',
            'fields': [
                {
                    'type': 'mrkdwn',
                    'text': '*Model Type:*'
                },
                {
                    'type': 'mrkdwn',
                    'text': '*Run ID:*'
                }
            ]
        }
    ]

    for model_type, run_id in run_dict.items():
        blocks.append(
            {
                'type': 'section',
                'fields': [
                    {
                        'type': 'mrkdwn',
                        'text': f'`{model_type}`'
                    },
                    {
                        'type': 'mrkdwn',
                        'text': f'`{run_id}`'
                    }
                ]
            }
        )

    guidelines = [
        {
            'type': 'context',
            'elements': [
                {
                    'type': 'mrkdwn',
                    'text': f'<!subteam^{sub_team}>\n'
                            f'Check the performance of the current models <{validation_path}|here>. '
                            f'Head to Mlflow to promote the new models and check the performance of the new models '
                            f'<{mlflow_path}|here>.\n'
                }
            ]
        }
    ]

    for model_name, run_id in run_dict.items():
        guidelines[0]['elements'].append(  # type: ignore
            {
                'type': 'mrkdwn',
                'text': f'Publish to production steps for `{model_name}` model:\n'
                        f'  1. Check the performance of the current model vs new model.\n'
                        f"  2. If the new model's performance is satisfactory, promote the `{model_name}` model in "
                        f'production by adding tags with key=stage and value=production.\n'
                        f'  3. If your model needs to be deployed in prediction-service, approve and merge automatic PR'
                        f' in the <{MODEL_REGISTRY_REPO}|ml-model-registry repository>.\n'
                        f'\n'
            }
        )

    blocks.extend(guidelines)

    return blocks


def create_slack_training_message(
        experiment_name: str,
        model_names: List[str],
        sub_team: str,
        validation_path: str
) -> List:
    """
    Create a Slack message for the specified mlflow experiment and model names after training.
    """

    experiment_id = get_experiment_id(MLFLOW_TRACKING_URI, experiment_name)
    mlflow_path = f'{MLFLOW_EXPERIMENT_URL}#/experiments/{str(experiment_id)}'

    run_id_dict = get_model_run_id_dict(MLFLOW_TRACKING_URI, experiment_name, model_names)
    blocks = create_training_message_blocks(experiment_name, run_id_dict, sub_team, validation_path, mlflow_path)

    return blocks
