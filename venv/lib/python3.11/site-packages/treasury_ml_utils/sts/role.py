from typing import ClassVar, Optional
import re

from treasury_ml_utils.sts.sts_errors import UnauthorizedSTSRequest


class AWSRole:
    """
    A class for the role ARN.
    """

    _prefix: ClassVar[str] = 'arn:aws:sts::'
    _pattern: ClassVar[re.Pattern] = re.compile(
        r'arn:aws:(sts|iam)::(?P<account_id>\d{12}):(?P<resource>assumed-role|role)'
        r'\/(?P<name>[a-zA-Z0-9_\-]+)(\/(?P<session_id>[a-zA-Z0-9_\-]+))?'
    )

    def __init__(self, account_id: str, resource: str, name: str, session_id: Optional[str] = None):
        self.account_id = account_id
        self.resource = resource
        self.name = name
        self.session_id = session_id

    @classmethod
    def from_arn(cls, arn: str) -> 'AWSRole':
        """
        Create a Role object from a role ARN.

        Example
        -------
        role_arn = 'arn:aws:sts::123456789012:assumed-role/role-name/session-name'

        Args:
            arn (str): The role ARN to parse.

        Returns:
            AWSRole: An AWSRole object with the parsed ARN.
        """
        match: Optional[re.Match] = re.match(cls._pattern, arn)
        if not match:
            raise UnauthorizedSTSRequest(f'Invalid role ARN: {arn}')

        groups = match.groupdict()
        return cls(**groups)

    def __hash__(self) -> int:
        return hash((self.account_id, self.name))

    def __eq__(self, value: object) -> bool:
        if not isinstance(value, AWSRole):
            return False
        name_matches = self.name == value.name
        account_matches = self.account_id == value.account_id
        return account_matches and name_matches
